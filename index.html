<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GLOBAL TRACK SYS - 3D Cyber Command</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=Rajdhani:wght@300;400;600&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --cyan: #00ffff;
            --cyan-glow: rgba(0, 255, 255, 0.6);
            --dark-bg: #000000;
            --panel-bg: rgba(0, 20, 30, 0.8);
            --grid-color: rgba(0, 255, 255, 0.2);
            --text-dim: rgba(255, 255, 255, 0.6);
            --deep-zoom-level: 1.1;
        }

        body {
            font-family: 'Rajdhani', sans-serif;
            background: var(--dark-bg);
            color: var(--cyan);
            overflow: hidden;
            height: 100vh;
        }

        #container {
            position: relative;
            width: 100%;
            height: 100%;
        }

        /* 3D Globe Canvas */
        #globe-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            transition: opacity 0.3s ease-in-out;
            background-color: transparent; 
            z-index: 5;
        }

        /* 2D Detailed Map Overlay (Base64 Image Data) */
        #map-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease-in-out, visibility 0.3s;
            z-index: 4; 
            pointer-events: none; 
            
            /* --- EMBEDDED BASE64 IMAGE DATA (Guaranteed to Load) --- */
            background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGAAAABgCAYAAADGm5hmAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAAVElEQVR42u3BAQEAAAABIP6fXgENoCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAhT5wH8D7LzK09aGgAAAABJRU5ErkJggg==');
            background-size: cover;
            background-position: center;
            filter: grayscale(0.1) contrast(1.5) brightness(1.2); /* Enhanced filter for visible grid lines */
        }

        #map-overlay.visible {
            opacity: 1;
            visibility: visible;
            pointer-events: auto;
        }

        /* HUD Overlay */
        .hud-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }
        
        /* --- (Rest of the boilerplate CSS) --- */

        .top-bar {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            padding: 20px 40px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: linear-gradient(180deg, rgba(0,0,0,0.9) 0%, transparent 100%);
            border-bottom: 1px solid var(--grid-color);
        }

        .logo {
            font-family: 'Orbitron', sans-serif;
            font-size: 24px;
            font-weight: 700;
            letter-spacing: 3px;
            text-shadow: 0 0 20px var(--cyan-glow);
        }

        .time-display {
            display: flex;
            gap: 30px;
            font-size: 14px;
        }

        .time-item {
            text-align: center;
        }

        .time-label {
            font-size: 10px;
            color: var(--text-dim);
            letter-spacing: 1px;
        }

        .time-value {
            font-family: 'Orbitron', monospace;
            font-size: 16px;
            color: var(--cyan);
        }

        .corner-panel {
            position: absolute;
            background: var(--panel-bg);
            border: 1px solid var(--cyan);
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.3);
            padding: 15px;
            backdrop-filter: blur(10px);
            pointer-events: auto;
        }

        .top-left {
            top: 80px;
            left: 20px;
            width: 280px;
        }

        .top-right {
            top: 80px;
            right: 20px;
            width: 280px;
        }

        .bottom-left {
            bottom: 20px;
            left: 20px;
            width: 350px;
        }

        .bottom-right {
            bottom: 20px;
            right: 20px;
            width: 280px;
        }

        .panel-title {
            font-family: 'Orbitron', sans-serif;
            font-size: 12px;
            letter-spacing: 2px;
            margin-bottom: 10px;
            padding-bottom: 8px;
            border-bottom: 1px solid var(--grid-color);
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            font-size: 13px;
            border-bottom: 1px solid rgba(0, 255, 255, 0.1);
        }

        .stat-label {
            color: var(--text-dim);
        }

        .stat-value {
            font-family: 'Orbitron', monospace;
            color: var(--cyan);
            text-shadow: 0 0 5px var(--cyan-glow);
        }

        .control-buttons {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }

        .cyber-btn {
            flex: 1;
            padding: 10px;
            background: rgba(0, 255, 255, 0.1);
            border: 1px solid var(--cyan);
            color: var(--cyan);
            font-family: 'Orbitron', sans-serif;
            font-size: 11px;
            letter-spacing: 1px;
            cursor: pointer;
            transition: all 0.3s;
            pointer-events: auto;
        }

        .cyber-btn:hover {
            background: var(--cyan);
            color: #000;
            box-shadow: 0 0 15px var(--cyan-glow);
        }

        .cyber-btn.active {
            background: var(--cyan);
            color: #000;
        }

        .waveform {
            height: 60px;
            margin-top: 10px;
            display: flex;
            align-items: flex-end;
            gap: 3px;
            justify-content: space-between;
        }

        .wave-bar {
            flex: 1;
            background: var(--cyan);
            box-shadow: 0 0 5px var(--cyan-glow);
            animation: wave-pulse 1.5s ease-in-out infinite;
        }

        @keyframes wave-pulse {
            0%, 100% { opacity: 0.3; }
            50% { opacity: 1; }
        }

        .data-grid {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            gap: 4px;
            margin-top: 10px;
        }

        .grid-cell {
            aspect-ratio: 1;
            background: rgba(0, 255, 255, 0.1);
            border: 1px solid var(--grid-color);
        }

        .grid-cell.active {
            background: var(--cyan);
            box-shadow: 0 0 10px var(--cyan-glow);
            animation: grid-blink 2s infinite;
        }

        @keyframes grid-blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }

        .status-log {
            max-height: 120px;
            overflow-y: auto;
            font-family: monospace;
            font-size: 11px;
            margin-top: 10px;
            padding: 8px;
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid var(--grid-color);
        }

        .log-entry {
            padding: 2px 0;
            color: var(--text-dim);
        }

        .log-entry.error {
            color: #ff3366;
        }

        .log-entry.success {
            color: #00ff88;
        }

        .crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 100px;
            height: 100px;
            pointer-events: none;
        }

        .crosshair::before,
        .crosshair::after {
            content: '';
            position: absolute;
            background: var(--cyan);
            opacity: 0.3;
        }

        .crosshair::before {
            width: 1px;
            height: 100%;
            left: 50%;
            transform: translateX(-50%);
        }

        .crosshair::after {
            height: 1px;
            width: 100%;
            top: 50%;
            transform: translateY(-50%);
        }

        ::-webkit-scrollbar {
            width: 6px;
        }

        ::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.3);
        }

        ::-webkit-scrollbar-thumb {
            background: var(--cyan);
            border-radius: 3px;
        }

        .corner-decoration {
            position: absolute;
            width: 40px;
            height: 40px;
            border: 1px solid var(--cyan);
            opacity: 0.5;
        }

        .corner-decoration.tl {
            top: 10px;
            left: 10px;
            border-right: none;
            border-bottom: none;
        }

        .corner-decoration.tr {
            top: 10px;
            right: 10px;
            border-left: none;
            border-bottom: none;
        }

        .corner-decoration.bl {
            bottom: 10px;
            left: 10px;
            border-right: none;
            border-top: none;
        }

        .corner-decoration.br {
            bottom: 10px;
            right: 10px;
            border-left: none;
            border-top: none;
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="map-overlay">
             </div>

        <canvas id="globe-canvas"></canvas>
        
        <div class="hud-overlay">
            <div class="top-bar">
                <div class="logo">GLOBAL TRACK SYS</div>
                <div class="time-display">
                    <div class="time-item">
                        <div class="time-label">LOS ANGELES</div>
                        <div class="time-value" id="time-la">--:--:--</div>
                    </div>
                    <div class="time-item">
                        <div class="time-label">LONDON</div>
                        <div class="time-value" id="time-ldn">--:--:--</div>
                    </div>
                    <div class="time-item">
                        <div class="time-label">TOKYO</div>
                        <div class="time-value" id="time-tky">--:--:--</div>
                    </div>
                    <div class="time-item">
                        <div class="time-label">SYDNEY</div>
                        <div class="time-value" id="time-syd">--:--:--</div>
                    </div>
                </div>
            </div>

            <div class="corner-panel top-left">
                <div class="panel-title">SYSTEM CONTROL</div>
                <div class="control-buttons">
                    <button class="cyber-btn" id="btn-start">START SCAN</button>
                    <button class="cyber-btn" id="btn-stop">STOP</button>
                </div>
                <div class="stat-row">
                    <span class="stat-label">STATUS:</span>
                    <span class="stat-value" id="system-status">STANDBY</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">THREATS:</span>
                    <span class="stat-value" id="threat-count">0</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">TOR NODES:</span>
                    <span class="stat-value" id="tor-count">0</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">CONNECTIONS:</span>
                    <span class="stat-value" id="connection-count">0</span>
                </div>
            </div>

            <div class="corner-panel top-right">
                <div class="panel-title">NETWORK TRAFFIC</div>
                <div class="stat-row">
                    <span class="stat-label">INBOUND:</span>
                    <span class="stat-value" id="inbound">0 MB/s</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">OUTBOUND:</span>
                    <span class="stat-value" id="outbound">0 MB/s</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">LATENCY:</span>
                    <span class="stat-value" id="latency">0 ms</span>
                </div>
                <div class="waveform" id="waveform"></div>
            </div>

            <div class="corner-panel bottom-left">
                <div class="panel-title">GLOBAL ACTIVITY MATRIX</div>
                <div class="data-grid" id="activity-grid"></div>
                <div class="status-log" id="status-log">
                    <div class="log-entry">System initialized...</div>
                    <div class="log-entry">Awaiting command...</div>
                </div>
            </div>

            <div class="corner-panel bottom-right">
                <div class="panel-title">COORDINATES</div>
                <div class="stat-row">
                    <span class="stat-label">LATITUDE:</span>
                    <span class="stat-value" id="coord-lat">0.000°</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">LONGITUDE:</span>
                    <span class="stat-value" id="coord-lon">0.000°</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">ALTITUDE:</span>
                    <span class="stat-value" id="coord-alt">2.5 AU</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">ZOOM LEVEL:</span>
                    <span class="stat-value" id="zoom-level">1.0x</span>
                </div>
            </div>

            <div class="corner-decoration tl"></div>
            <div class="corner-decoration tr"></div>
            <div class="corner-decoration bl"></div>
            <div class="corner-decoration br"></div>

            <div class="crosshair"></div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // --- CONSTANTS ---
        const DEEP_ZOOM_THRESHOLD = 1.1; 
        const CHENNAI_LAT = 13.061;
        const CHENNAI_LNG = 80.230;

        // --- DOM Elements ---
        const globeCanvas = document.getElementById('globe-canvas');
        const mapOverlay = document.getElementById('map-overlay');

        // ===== THREE.JS GLOBE SETUP: BRIGHTER LIGHTING AND NEW TEXTURE =====
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ canvas: globeCanvas, antialias: true, alpha: true });
        
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        camera.position.z = 2.5; 

        // Lighting: Increased intensity for better map visibility
        const ambientLight = new THREE.AmbientLight(0x404040, 3.0); 
        scene.add(ambientLight);
        const dirLight = new THREE.DirectionalLight(0xeeeeee, 1.5); 
        dirLight.position.set(5, 3, 5); 
        scene.add(dirLight);

        // GLOBE CREATION 
        const globeGeometry = new THREE.SphereGeometry(1, 128, 128);
        const textureLoader = new THREE.TextureLoader();
        
        // TEXTURE: Uses a clearer, non-night map for better daylight contrast 
        const HIGH_RES_MAP = 'https://unpkg.com/three-globe/example/img/earth-blue-marble.jpg'; 
        
        const earthMaterial = new THREE.MeshPhongMaterial({
            color: 0xffffff,
            transparent: true,
            opacity: 1.0, 
            shininess: 10,
            specular: 0x111111,
        });
        const solidGlobe = new THREE.Mesh(globeGeometry, earthMaterial);
        scene.add(solidGlobe);

        textureLoader.load(
            HIGH_RES_MAP,
            (texture) => {
                solidGlobe.material.map = texture;
                // Apply a slight blue-green filter
                solidGlobe.material.color.setHex(0x354060); 
                solidGlobe.material.needsUpdate = true;
            }
        );
        
        // Wireframe
        const wireframeMaterial = new THREE.MeshBasicMaterial({
            color: 0x00ffff, wireframe: true, transparent: true, opacity: 0.15
        });
        const wireframeGlobe = new THREE.Mesh(globeGeometry, wireframeMaterial);
        scene.add(wireframeGlobe);

        // Glow
        const glowGeometry = new THREE.SphereGeometry(0.98, 32, 32);
        const glowMaterial = new THREE.MeshBasicMaterial({
            color: 0x00ffff, transparent: true, opacity: 0.05, side: THREE.BackSide
        });
        const glowSphere = new THREE.Mesh(glowGeometry, glowMaterial);
        scene.add(glowSphere);

        // Atmosphere
        const atmosphereGeometry = new THREE.SphereGeometry(1.15, 32, 32);
        const atmosphereMaterial = new THREE.MeshBasicMaterial({
            color: 0x00ffff, transparent: true, opacity: 0.05, side: THREE.BackSide
        });
        const atmosphere = new THREE.Mesh(atmosphereGeometry, atmosphereMaterial);
        scene.add(atmosphere);

        // Grid Lines (simplified)
        const createGridLines = () => {
            const gridGroup = new THREE.Group();
            const segments = 128;
            
            const lineMaterial = new THREE.LineBasicMaterial({ color: 0x00ffff, transparent: true, opacity: 0.6 });
            
            for (let i = 1; i < 18; i++) {
                const phi = (Math.PI * i) / 18;
                const points = [];
                const radius = Math.sin(phi);
                const y = Math.cos(phi);
                
                for (let j = 0; j <= segments; j++) {
                    const theta = (j / segments) * Math.PI * 2;
                    points.push(new THREE.Vector3(radius * Math.cos(theta), y, radius * Math.sin(theta)));
                }
                
                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                gridGroup.add(new THREE.Line(geometry, lineMaterial));
            }
            
            for (let i = 0; i < 36; i++) {
                const theta = (2 * Math.PI * i) / 36;
                const points = [];
                for (let j = 0; j <= segments; j++) {
                    const phi = (j / segments) * Math.PI;
                    points.push(new THREE.Vector3(Math.sin(phi) * Math.cos(theta), Math.cos(phi), Math.sin(phi) * Math.sin(theta)));
                }
                
                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                gridGroup.add(new THREE.Line(geometry, lineMaterial));
            }
            
            return gridGroup;
        };
        
        const gridLines = createGridLines();
        scene.add(gridLines);

        // Markers and Connections groups
        const markers = [];
        const markerGroup = new THREE.Group();
        scene.add(markerGroup);
        const connections = [];

        // --- ADD MARKER / CONNECTION FUNCTIONS ---
        function addMarker(lat, lon, color = 0x00ffff, size = 0.02) {
            const R = 1.02;
            const phi = (90 - lat) * (Math.PI / 180);
            const theta = (lon + 180) * (Math.PI / 180);
            const x = -(R * Math.sin(phi) * Math.cos(theta));
            const y = R * Math.cos(phi);
            const z = R * Math.sin(phi) * Math.sin(theta);
            
            const markerGeometry = new THREE.SphereGeometry(size * 1.5, 16, 16);
            const markerMaterial = new THREE.MeshBasicMaterial({ color: color, transparent: false, opacity: 1 });
            const marker = new THREE.Mesh(markerGeometry, markerMaterial);
            marker.position.set(x, y, z);
            
            // Add light for glow effect
            const light = new THREE.PointLight(color, 1, 0.3);
            light.position.set(x, y, z);
            
            markerGroup.add(marker);
            markerGroup.add(light);
            markers.push({ marker, light, lat, lon });
        }
        
        function clearMarkers() { 
            markers.forEach(m => {
                markerGroup.remove(m.marker);
                markerGroup.remove(m.light);
            }); 
            markers.length = 0; 
        }
        
        function addConnection(lat1, lon1, lat2, lon2) {
            const R = 1.01;
            const phi1 = (90 - lat1) * (Math.PI / 180);
            const theta1 = (lon1 + 180) * (Math.PI / 180);
            const phi2 = (90 - lat2) * (Math.PI / 180);
            const theta2 = (lon2 + 180) * (Math.PI / 180);
            
            const x1 = -(R * Math.sin(phi1) * Math.cos(theta1));
            const y1 = R * Math.cos(phi1);
            const z1 = R * Math.sin(phi1) * Math.sin(theta1);
            
            const x2 = -(R * Math.sin(phi2) * Math.cos(theta2));
            const y2 = R * Math.cos(phi2);
            const z2 = R * Math.sin(phi2) * Math.sin(theta2);

            const curve = new THREE.QuadraticBezierCurve3(
                new THREE.Vector3(x1, y1, z1),
                new THREE.Vector3((x1 + x2) * 0.5, (y1 + y2) * 0.5 + 0.3, (z1 + z2) * 0.5),
                new THREE.Vector3(x2, y2, z2)
            );

            const points = curve.getPoints(50);
            const material = new THREE.LineBasicMaterial({
                color: 0x00ffff,
                transparent: true,
                opacity: 0.8
            });
            const line = new THREE.Line(new THREE.BufferGeometry().setFromPoints(points), material);
            scene.add(line);
            connections.push(line);
        }

        function clearConnections() {
            connections.forEach(line => scene.remove(line));
            connections.length = 0;
        }

        // ===== MOUSE CONTROLS: ZOOM LOGIC =====
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };
        let rotationVelocity = { x: 0, y: 0 };

        globeCanvas.addEventListener('mousedown', (e) => {
            isDragging = true;
            previousMousePosition = { x: e.clientX, y: e.clientY };
        });

        globeCanvas.addEventListener('mousemove', (e) => {
            if (isDragging) {
                const deltaX = e.clientX - previousMousePosition.x;
                const deltaY = e.clientY - previousMousePosition.y;
                rotationVelocity.x = deltaY * 0.005;
                rotationVelocity.y = deltaX * 0.005;
                previousMousePosition = { x: e.clientX, y: e.clientY };
            }
        });

        globeCanvas.addEventListener('mouseup', () => {
            isDragging = false;
        });

        const handleWheel = (e) => {
            e.preventDefault();
            
            camera.position.z += e.deltaY * 0.0005; 
            
            camera.position.z = Math.max(1.01, Math.min(5, camera.position.z));
            updateZoomLevel();
            updateView();
        };

        globeCanvas.addEventListener('wheel', handleWheel);
        mapOverlay.addEventListener('wheel', handleWheel);

        // ===== VIEW MANAGEMENT AND SYNCHRONIZATION =====
        function updateView() {
            const isDeepZoom = camera.position.z <= DEEP_ZOOM_THRESHOLD;
            const mapOverlayVisible = mapOverlay.classList.contains('visible');

            if (isDeepZoom && !mapOverlayVisible) {
                // --- SWITCH TO 2D MAP OVERLAY ---
                mapOverlay.classList.add('visible');
                globeCanvas.style.opacity = '0'; 
                globeCanvas.style.pointerEvents = 'none';

            } else if (!isDeepZoom && mapOverlayVisible) {
                // --- SWITCH BACK TO 3D GLOBE ---
                mapOverlay.classList.remove('visible');
                globeCanvas.style.opacity = '1'; 
                globeCanvas.style.pointerEvents = 'auto';
            }
        }


        // ===== ANIMATION LOOP: CRITICAL TRANSITION CHECK =====
        function animate() {
            requestAnimationFrame(animate);
            
            if (!isDragging) {
                rotationVelocity.x *= 0.95;
                rotationVelocity.y *= 0.95;
            }

            // Only render Three.js scene if the globe is visible (not zoomed in)
            if (camera.position.z > DEEP_ZOOM_THRESHOLD) {
                solidGlobe.rotation.y += rotationVelocity.y;
                solidGlobe.rotation.x += rotationVelocity.x;
                wireframeGlobe.rotation.y += rotationVelocity.y;
                wireframeGlobe.rotation.x += rotationVelocity.x;
                gridLines.rotation.y += rotationVelocity.y;
                gridLines.rotation.x += rotationVelocity.x;
                markerGroup.rotation.y += rotationVelocity.y;
                markerGroup.rotation.x += rotationVelocity.x;
                
                renderer.render(scene, camera);
            }
        }
        animate();

        // ===== HUD FUNCTIONALITY (Modified Zoom/Coordinate) =====

        function updateCoordinates() {
            if (camera.position.z <= DEEP_ZOOM_THRESHOLD) {
                document.getElementById('coord-lat').textContent = `${CHENNAI_LAT}°`;
                document.getElementById('coord-lon').textContent = `${CHENNAI_LNG}°`;
            } else {
                document.getElementById('coord-lat').textContent = `${(Math.random() * 180 - 90).toFixed(3)}°`;
                document.getElementById('coord-lon').textContent = `${(Math.random() * 360 - 180).toFixed(3)}°`;
            }
        }

        function updateZoomLevel() {
            const minZ = 1.01;
            const maxZ = 5;
            const range = maxZ - minZ;
            const normalizedZ = (maxZ - camera.position.z) / range;
            const zoom = 1 + normalizedZ * 15; 
            
            document.getElementById('zoom-level').textContent = `${zoom.toFixed(1)}x`;
            
            updateCoordinates();
        }
        updateZoomLevel();

        // --- (Rest of HUD functions are unchanged) ---
        function updateTimes() {
            const now = new Date();
            const formatTime = (offset) => {
                const utc = now.getTime() + (now.getTimezoneOffset() * 60000);
                const localTime = new Date(utc + (3600000 * offset));
                return localTime.toLocaleTimeString('en-US', { hour12: false });
            };
            
            document.getElementById('time-la').textContent = formatTime(-7);
            document.getElementById('time-ldn').textContent = formatTime(1);
            document.getElementById('time-tky').textContent = formatTime(9);
            document.getElementById('time-syd').textContent = formatTime(11);
        }
        setInterval(updateTimes, 1000);
        updateTimes();

        function initActivityGrid() {
            const grid = document.getElementById('activity-grid');
            for (let i = 0; i < 64; i++) {
                const cell = document.createElement('div');
                cell.className = 'grid-cell';
                grid.appendChild(cell);
            }
        }
        initActivityGrid();

        function updateActivityGrid() {
            const cells = document.querySelectorAll('.grid-cell');
            cells.forEach(cell => {
                if (Math.random() > 0.9) {
                    cell.classList.add('active');
                    setTimeout(() => cell.classList.remove('active'), 2000);
                }
            });
        }

        function initWaveform() {
            const waveform = document.getElementById('waveform');
            for (let i = 0; i < 20; i++) {
                const bar = document.createElement('div');
                bar.className = 'wave-bar';
                bar.style.height = '20%';
                bar.style.animationDelay = `${i * 0.1}s`;
                waveform.appendChild(bar);
            }
        }
        initWaveform();

        function updateWaveform() {
            const bars = document.querySelectorAll('.wave-bar');
            bars.forEach(bar => {
                bar.style.height = `${Math.random() * 80 + 20}%`;
            });
        }

        function updateNetworkStats() {
            document.getElementById('inbound').textContent = `${(Math.random() * 100).toFixed(1)} MB/s`;
            document.getElementById('outbound').textContent = `${(Math.random() * 50).toFixed(1)} MB/s`;
            document.getElementById('latency').textContent = `${Math.floor(Math.random() * 100)} ms`;
        }

        function addLog(message, type = 'normal') {
            const log = document.getElementById('status-log');
            const entry = document.createElement('div');
            entry.className = `log-entry ${type}`;
            const time = new Date().toLocaleTimeString();
            entry.textContent = `[${time}] ${message}`;
            log.appendChild(entry);
            log.scrollTop = log.scrollHeight;
        }

        let analysisRunning = false;
        let updateInterval = null;

        document.getElementById('btn-start').addEventListener('click', async () => {
            if (analysisRunning) return;
            
            analysisRunning = true;
            document.getElementById('system-status').textContent = 'SCANNING';
            document.getElementById('btn-start').classList.add('active');
            addLog('Analysis started...', 'success');
            
            updateInterval = setInterval(() => {
                updateActivityGrid();
                updateWaveform();
                updateNetworkStats();
            }, 1500);

            // Fetch data from the Flask backend (server.py)
            try {
                const response = await fetch('/start_analysis', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ action: 'start' })
                });
                
                const data = await response.json();
                
                if (response.ok) {
                    const threatCount = data.report?.detections?.length || 0;
                    const torNodes = data.report?.statistics?.unique_entries || 0;
                    
                    document.getElementById('threat-count').textContent = threatCount;
                    document.getElementById('tor-count').textContent = torNodes;
                    document.getElementById('connection-count').textContent = torNodes;
                    document.getElementById('system-status').textContent = 'ACTIVE';

                    addLog(`Detection: ${data.detection_status}`, data.detection_status === 'TOR' ? 'error' : 'success');
                    
                    // --- CRITICAL FIX: PROCESS REAL JSON DATA AND MAP ALL AVAILABLE NODES ---
                    clearMarkers();
                    clearConnections();

                    if (data.report && data.report.detections) {
                        data.report.detections.forEach(det => {
                            const entry = det.entry_node;
                            const exit = det.exit_node;
                            
                            const entryLat = parseFloat(entry?.lat);
                            const entryLon = parseFloat(entry?.lon);
                            const exitLat = parseFloat(exit?.lat);
                            const exitLon = parseFloat(exit?.lon);
                            
                            // 1. Plot Entry Node if coordinates are valid
                            const isEntryValid = !isNaN(entryLat) && !isNaN(entryLon);
                            if (isEntryValid) {
                                addMarker(entryLat, entryLon, 0x00ffff, 0.025);
                                addLog(`Entry: ${entry.country} (${entry.ip})`, 'normal');
                            }
                            
                            // 2. Plot Exit Node if coordinates are valid
                            const isExitValid = !isNaN(exitLat) && !isNaN(exitLon);
                            if (isExitValid) {
                                addMarker(exitLat, exitLon, 0xff3366, 0.025);
                                addLog(`Exit: ${exit.country} (${exit.ip})`, 'error');
                            }
                            
                            // 3. Draw Connection Line ONLY if BOTH nodes are valid
                            if (isEntryValid && isExitValid) {
                                addConnection(entryLat, entryLon, exitLat, exitLon);
                            }
                        });
                        
                        addLog(`Visualized ${data.report.detections.length} total paths/nodes.`, 'success');
                    } else {
                        addLog(`No TOR paths detected in report.`, 'normal');
                    }
                    
                } else {
                    throw new Error(data.msg || 'Analysis failed on server.');
                }

            } catch (error) {
                 // Fallback to Demo mode if server fails or is not running
                addLog(`Server Error: ${error.message}. Running sample data simulation.`, 'error');
                
                const sampleLocations = [
                    { lat: 51.5074, lon: -0.1278, name: 'London' },
                    { lat: CHENNAI_LAT, lon: CHENNAI_LNG, name: 'Chennai' },
                    { lat: 35.6762, lon: 139.6503, name: 'Tokyo' },
                    { lat: 40.7128, lon: -74.0060, name: 'New York' },
                    { lat: 48.8566, lon: 2.3522, name: 'Paris' },
                    { lat: 1.3521, lon: 103.8198, name: 'Singapore' }
                ];
                
                clearMarkers();
                clearConnections();
                
                const numConnections = 5;
                for (let i = 0; i < numConnections; i++) {
                    const entry = sampleLocations[Math.floor(Math.random() * sampleLocations.length)];
                    let exit = sampleLocations[Math.floor(Math.random() * sampleLocations.length)];
                    
                    addMarker(entry.lat, entry.lon, 0x00ffff, 0.025);
                    addMarker(exit.lat, exit.lon, 0xff3366, 0.025);
                    addConnection(entry.lat, entry.lon, exit.lat, exit.lon);
                    
                    addLog(`Demo Path: ${entry.name} → ${exit.name}`, 'normal');
                }
                
                document.getElementById('threat-count').textContent = numConnections;
                document.getElementById('tor-count').textContent = numConnections * 2;
                document.getElementById('connection-count').textContent = numConnections;
                document.getElementById('system-status').textContent = 'DEMO';
            }
        });
        
        document.getElementById('btn-stop').addEventListener('click', () => {
            if (!analysisRunning) return;
            
            analysisRunning = false;
            document.getElementById('system-status').textContent = 'STANDBY';
            document.getElementById('btn-start').classList.remove('active');
            
            clearInterval(updateInterval);
            updateInterval = null;
            
            clearMarkers();
            clearConnections();
            
            document.getElementById('threat-count').textContent = '0';
            document.getElementById('tor-count').textContent = '0';
            document.getElementById('connection-count').textContent = '0';
            
            addLog('Analysis stopped', 'normal');
            addLog('All systems reset', 'normal');
        });
        
        setTimeout(() => {
            addLog('System initialized', 'success');
            addLog('Awaiting scan command...', 'normal');
        }, 500);
    </script>
</body>
</html>